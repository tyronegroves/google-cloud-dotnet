<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Google.Cloud.Diagnostics.AspNetCore | Google.Cloud.Diagnostics.AspNetCore </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Google.Cloud.Diagnostics.AspNetCore | Google.Cloud.Diagnostics.AspNetCore ">
    <meta name="generator" content="docfx 2.39.1.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="googleclouddiagnosticsaspnetcore">Google.Cloud.Diagnostics.AspNetCore</h1>

<p><code>Google.Cloud.Diagnostics.AspNetCore</code> is an ASP.NET Core instrumentation library for Google Stackdriver.
It allows for simple integration of Stackdriver into ASP.NET applications with minimal code changes.</p>
<p>This package supports Stackdriver Error Reporting, Stackdriver
Logging and Stackdriver Trace, and integrates with ASP.NET Core 2.1
(which is the long-term support release of ASP.NET Core 2.x) and above.</p>
<p>Note:
This documentation is for version <code>4.0.0-beta02</code> of the library.
Some samples may not work with other versions.</p>
<h1 id="installation">Installation</h1>
<p>Install the <code>Google.Cloud.Diagnostics.AspNetCore</code> package from NuGet. Add it to
your project in the normal way (for example by right-clicking on the
project in Visual Studio and choosing &quot;Manage NuGet Packages...&quot;).
Please ensure you enable pre-release packages (for example, in the
Visual Studio NuGet user interface, check the &quot;Include prerelease&quot;
box). Some of the following samples might only work with the latest 
pre-release version (<code>4.0.0-beta02</code>) of <code>Google.Cloud.Diagnostics.AspNetCore</code>.</p>
<h1 id="authentication">Authentication</h1>
<p>When running on Google Cloud Platform, no action needs to be taken to authenticate.</p>
<p>Otherwise, the simplest way of authenticating your API calls is to
download a service account JSON file then set the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable to refer to it.
The credentials will automatically be used to authenticate. See the <a href="https://cloud.google.com/docs/authentication/getting-started">Getting Started With
Authentication</a> guide for more details.</p>
<h1 id="note">Note</h1>
<p>The Google.Cloud.Diagnostics.AspNetCore package attempts to collect the filename and line number when
entries are collected. However, to be able to collect this information PDBs must be included with
the deployed code.</p>
<h1 id="getting-started">Getting started</h1>
<h2 id="initializing-google-diagnostics">Initializing Google Diagnostics</h2>
<p>The easiest way to initialize Google Diagnostics services is using
the <code>UseGoogleDiagnostics</code> extentension method on <code>IWebHostBuilder</code>.
This configures Logging, Tracing and Error Reporting middleware.</p>
<p>If your application is runnng on Google App Engine, Google
Kubernetes Engine, Google Cloud Run or Google Compute Engine, you
don&#39;t need to provide a value for <code>ProjectID</code>, <code>Service</code> and
<code>Version</code> since they can be automatically obtained by the
<code>UseGoogleDiagnostics</code> method as far as they make sense for the
environment. (Not every environment has the concept of a &quot;service&quot;
or &quot;version&quot;.) The values used will be the ones associated with the running application.</p>
<p>If your application is running outside of GCP, including when it
runs locally, then you&#39;ll need to provide the <code>ProjectID</code> of the
Google Cloud Project in which to store the diagnostic information as
well as the <code>Service</code> and <code>Version</code> with which to identify your
application.</p>
<pre><code class="lang-cs">var webHostBuilder = new WebHostBuilder()
    // Replace ProjectId with your Google Cloud Project ID.
    // Replace Service with a name or identifier for the service.
    // Replace Version with a version for the service.
    .UseGoogleDiagnostics(ProjectId, Service, Version)
    .UseStartup&lt;Startup&gt;();
</code></pre><p>You can still initialize the separate components using the extension
methods below. This can be useful if you only need to use some of
the components or, for instance, if you need to access the
<code>Configuration</code> property on the <code>Startup</code> class to obtain values for
<code>ProjectID</code>, <code>Service</code> or <code>Version</code>.</p>
<p>Optional parameters on <code>UseGoogleDiagnostics</code> are also available to
specify options for each of the components (logging, tracing and
error reporting). This is typically useful for diagnosing problems,
as described below</p>
<h1 id="error-reporting">Error Reporting</h1>
<h2 id="registering-error-reporting">Registering Error Reporting</h2>
<pre><code class="lang-cs">public void ConfigureServices(IServiceCollection services)
{
    services.AddGoogleExceptionLogging(options =&gt;
    {
        // Replace ProjectId with your Google Cloud Project ID.
        options.ProjectId = ProjectId;
        // Replace Service with a name or identifier for the service.
        options.ServiceName = Service;
        // Replace Version with a version for the service.
        options.Version = Version;
    });

    // ...any other services your application requires.

    services.AddMvc();
}

public void Configure(IApplicationBuilder app)
{
    // Use before handling any requests to ensure all unhandled exceptions are reported.
    app.UseGoogleExceptionLogging();

    // ...any other configuration your application requires.

    app.UseMvc(routes =&gt;
    {
        routes.MapRoute(
            name: &quot;default&quot;,
            template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });
}
</code></pre><h2 id="log-exceptions">Log Exceptions</h2>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// This method catches an exception thrown by another method and explicitly
/// logs that exception.
/// The &lt;see cref=&quot;IExceptionLogger&quot;/&gt; is populated by dependency injection 
/// thanks to the use of the &lt;see cref=&quot;FromServicesAttribute&quot;/&gt; attribute.
/// &lt;/summary&gt;
public void CatchesAndLogsException(string id, [FromServices]IExceptionLogger exceptionLogger)
{
    try
    {
        // This method call throws an exception.
        ThrowsException(id);
    }
    catch (Exception e)
    {
        exceptionLogger.Log(e);
    }
}
</code></pre><h1 id="logging">Logging</h1>
<h2 id="initializing-logging">Initializing Logging</h2>
<p>Logging can be initialized using <code>ConfigureServices</code> when
constructing a <code>WebHostBuilder()</code>:</p>
<pre><code class="lang-cs">return new WebHostBuilder()
    .ConfigureServices(services =&gt;
    {
        // Replace projectId with your Google Cloud Project ID.
        services.AddSingleton&lt;ILoggerProvider&gt;(sp =&gt; GoogleLoggerProvider.Create(sp, projectId));
    })
    .UseStartup&lt;Startup&gt;();
</code></pre><p>Or using <code>ConfigureLogging</code> when constructing a <code>WebHostBuilder()</code>:</p>
<pre><code class="lang-cs">return new WebHostBuilder()
    .ConfigureLogging(builder =&gt; builder.AddProvider(GoogleLoggerProvider.Create(serviceProvider: null, projectId)))
    .UseStartup&lt;Startup&gt;();
</code></pre><p>Note that this approach does not support custom services (such as
log entry label providers) being used as the service provider is
not available within <code>ConfigureLogging</code>.</p>
<p>Alternatively, logging can be configured within the application&#39;s
<code>ConfigureServices</code> method:</p>
<pre><code class="lang-cs">public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
}

public void Configure(IApplicationBuilder app, ILoggerFactory loggerFactory)
{
    // Replace ProjectId with your Google Cloud Project ID.
    loggerFactory.AddGoogle(app.ApplicationServices, ProjectId);

    // ...any other configuration your application requires.

    app.UseMvc(routes =&gt;
    {
        routes.MapRoute(
            name: &quot;default&quot;,
            template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });
}
</code></pre><h2 id="log">Log</h2>
<pre><code class="lang-cs">public class LoggingSamplesController : Controller
{
    /// &lt;summary&gt;
    /// This method logs an Information level message.
    /// The &lt;see cref=&quot;ILogger&quot;/&gt; is populated by dependency injection
    /// thanks to the use of the &lt;see cref=&quot;FromServicesAttribute&quot;/&gt; attribute.
    /// &lt;/summary&gt;
    public void LogInformation(string id, [FromServices]ILogger&lt;LoggingSamplesController&gt; logger)
    {
        // Log whatever message you want to log.
        logger.LogInformation(id);
    }
}
</code></pre><h2 id="troubleshooting-logging">Troubleshooting Logging</h2>
<p>Sometimes it is neccessary to diagnose log operations. It might be that logging is failing or that
we simply cannot find where the logs are being stored in GCP. What follows are a couple of code samples
that can be useful to find out what might be wrong with logging operations.</p>
<h3 id="propagating-exceptions">Propagating Exceptions</h3>
<p>By default the Google Logger won&#39;t propagate any exceptions thrown during logging. This is to protect the
application from crashing if logging is not possible. But logging is an important aspect of most applications
so at times we need to know if it&#39;s failing and why. The following
example shows how to configure Google Logger so that it propagates exceptions thrown during logging.</p>
<pre><code class="lang-cs">// Explicitly create logger options that will propagate any exceptions thrown
// during logging.
RetryOptions retryOptions = RetryOptions.NoRetry(ExceptionHandling.Propagate);
// Also set the no buffer option so that writing the logs is attempted immediately.
BufferOptions bufferOptions = BufferOptions.NoBuffer();
LoggerOptions loggerOptions = LoggerOptions.Create(bufferOptions: bufferOptions, retryOptions: retryOptions);
return new WebHostBuilder()
    .UseGoogleDiagnostics(projectId, loggerOptions: loggerOptions)
    .UseStartup&lt;Startup&gt;();
</code></pre><p>The same <code>LoggerOptions</code> can be specified in any of the other ways
of registering logging.</p>
<h3 id="finding-out-the-url-where-logs-are-written">Finding out the URL where logs are written</h3>
<p>Depending on where your code is running and the options you provided
for creating a Google Logger, it might be hard to find your logs in
the GCP Console. We have provided a way for you to obtain the URL
where your logs can be found.</p>
<p>As the following code sample shows, you only need to pass a
<code>System.IO.TextWriter</code> (typically <code>Console.Out</code> or <code>Console.Error</code>)
as part of the options when registering logging. When the
<code>GoogleLoggerProvider</code> is initialized, the URL where its logs can be
found will be written to the given text writer.</p>
<pre><code class="lang-cs">return new WebHostBuilder()
    .UseGoogleDiagnostics(projectId, loggerOptions: LoggerOptions.Create(loggerDiagnosticsOutput: Console.Out))
    .UseStartup&lt;Startup&gt;();
</code></pre><p>Please note that since this is a Google Logger diagnostics feature,
we don&#39;t respect settings for exception handling, i.e. we propagate
any exception thrown while writing the URL to the given text writer
so you know what might be happening. This feature should only be
activated as a one off, if you are having trouble trying to find
your logs in the GCP Console, and not as a permanent feature in
production code. To deactivate this feature simply stop passing a
<code>System.IO.TextWriter</code> as part of the options when creating a Google
Logger.</p>
<h1 id="tracing">Tracing</h1>
<h2 id="initializing-tracing">Initializing Tracing</h2>
<pre><code class="lang-cs">public void ConfigureServices(IServiceCollection services)
{
    // The line below is needed for trace ids to be added to logs.
    services.AddHttpContextAccessor();

    // Replace ProjectId with your Google Cloud Project ID.
    services.AddGoogleTrace(options =&gt;
    {
        options.ProjectId = ProjectId;
    });

    services.AddMvc();
}

public void Configure(IApplicationBuilder app)
{
    // Use at the start of the request pipeline to ensure the entire request is traced.
    app.UseGoogleTrace();

    // ...any other configuration your application requires.

    app.UseMvc(routes =&gt;
    {
        routes.MapRoute(
            name: &quot;default&quot;,
            template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });
}
</code></pre><h2 id="troubleshooting-tracing">Troubleshooting Tracing</h2>
<p>Just as with logging, trace is most easily diagnosed by removing
buffering and propagating exceptions immediately.</p>
<pre><code class="lang-cs">// Explicitly create trace options that will propagate any exceptions thrown during tracing.
RetryOptions retryOptions = RetryOptions.NoRetry(ExceptionHandling.Propagate);
// Also set the no buffer option so that tracing is attempted immediately.
BufferOptions bufferOptions = BufferOptions.NoBuffer();
TraceOptions traceOptions = TraceOptions.Create(bufferOptions: bufferOptions, retryOptions: retryOptions);
</code></pre><p>The options can be specified wherever you are configuring tracing.</p>
<h2 id="tracing-in-mvc-controllers">Tracing in MVC Controllers</h2>
<p>To use the <code>IManagedTracer</code> in MVC controllers you can either inject the singleton instance of 
<code>IManagedTracer</code> into the controller&#39;s constructor (see <code>TraceSamplesConstructorController</code>) or you
can in inject the <code>IManagedTracer</code> into the action method using the <code>[FromServices]</code> attribute
(see <code>TraceSamplesMethodController</code>).</p>
<pre><code class="lang-cs">public class TraceSamplesConstructorController : Controller
{
    private readonly IManagedTracer _tracer;

    /// &lt;summary&gt;
    /// The &lt;see cref=&quot;IManagedTracer&quot;/&gt; is populated by dependency injection.
    /// &lt;/summary&gt;
    public TraceSamplesConstructorController(IManagedTracer tracer)
    {
        _tracer = tracer;
    }

    public void TraceHelloWorld(string id)
    {
        // Change the name of the span to what makese sense in your context.
        using (_tracer.StartSpan(id))
        {
            // The code whose execution is to be included in the span goes here.
            ViewData[&quot;Message&quot;] = &quot;Hello World.&quot;;
        }
    }
}
</code></pre><pre><code class="lang-cs">public class TraceSamplesMethodController : Controller
{
    /// &lt;summary&gt;
    /// Manually trace a set of operations.
    /// The &lt;see cref=&quot;IManagedTracer&quot;/&gt; is populated by dependency injection
    /// thanks to the use of the &lt;see cref=&quot;FromServicesAttribute&quot;/&gt; attribute.
    /// &lt;/summary&gt;
    public void TraceHelloWorld(string id, [FromServices] IManagedTracer tracer)
    {
        // Change the name of the span to what makese sense in your context.
        using (tracer.StartSpan(id))
        {
            // The code whose execution is to be included in the span goes here.
            ViewData[&quot;Message&quot;] = &quot;Hello World.&quot;;
        }
    }
}
</code></pre><h2 id="manual-tracing">Manual Tracing</h2>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Manually trace a set of operations.
/// The &lt;see cref=&quot;IManagedTracer&quot;/&gt; is populated by dependency injection
/// thanks to the use of the &lt;see cref=&quot;FromServicesAttribute&quot;/&gt; attribute.
/// &lt;/summary&gt;
public void TraceHelloWorld(string id, [FromServices] IManagedTracer tracer)
{
    // Change the name of the span to what makese sense in your context.
    using (tracer.StartSpan(id))
    {
        // The code whose execution is to be included in the span goes here.
        ViewData[&quot;Message&quot;] = &quot;Hello World.&quot;;
    }
}
</code></pre><pre><code class="lang-cs">/// &lt;summary&gt;
/// Manually trace a specific Action or Func&lt;T&gt;.
/// The &lt;see cref=&quot;IManagedTracer&quot;/&gt; is populated by dependency injection
/// thanks to the use of the &lt;see cref=&quot;FromServicesAttribute&quot;/&gt; attribute.
/// &lt;/summary&gt;
public void TraceHelloWorldRunIn(string id, [FromServices]IManagedTracer tracer)
{
    tracer.RunInSpan(
        // The Action or Func&lt;T&gt; to be traced.
        () =&gt;
        {
            // The code whose execution is to be included in the span goes here.
            ViewData[&quot;Message&quot;] = &quot;Hello World.&quot;;
        },
        // The name of the span.
        id);
}
</code></pre><h2 id="trace-outgoing-http-requests-recommended">Trace Outgoing HTTP Requests (recommended)</h2>
<p>The <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-2.1">recommended way of creating HttpClient</a> in ASP.NET Core 2.0 and upwards is to use the
<code>System.Net.Http.IHttpClientFactory</code> defined in the Microsoft.Extensions.Http package.
The following example demonstrates how to register and use an HttpClient using Google Trace so that it traces
outgoing requests.</p>
<h3 id="configuration">Configuration</h3>
<pre><code class="lang-cs">public void ConfigureServices(IServiceCollection services)
{
    // The line below is needed for trace ids to be added to logs.
    services.AddHttpContextAccessor();

    // Replace ProjectId with your Google Cloud Project ID.
    services.AddGoogleTrace(options =&gt;
    {
        options.ProjectId = ProjectId;
    });

    // Register an HttpClient for outgoing requests.
    services.AddHttpClient(&quot;tracesOutgoing&quot;)
        // The next call guarantees that trace information is propagated for outgoing
        // requests that are already being traced.
        .AddOutgoingGoogleTraceHandler();

    services.AddMvc();
}

public void Configure(IApplicationBuilder app)
{
    // Use at the start of the request pipeline to ensure the entire request is traced.
    app.UseGoogleTrace();

    // ...any other configuration your application requires.

    app.UseMvc(routes =&gt;
    {
        routes.MapRoute(
            name: &quot;default&quot;,
            template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });
}
</code></pre><h3 id="usage">Usage</h3>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Use the &lt;see cref=&quot;IHttpClientFactory&quot;/&gt; to create an HttpClient that will guarantee
/// the tracing of outgoing requests.
/// The &lt;see cref=&quot;IHttpClientFactory&quot;/&gt; is populated by dependency injection
/// thanks to the use of the &lt;see cref=&quot;FromServicesAttribute&quot;/&gt; attribute.
/// &lt;/summary&gt;
public async Task&lt;HttpResponseMessage&gt; TraceOutgoingClientFactory([FromServices] IHttpClientFactory clientFactory)
{
    var httpClient = clientFactory.CreateClient(&quot;tracesOutgoing&quot;);
    // Any code that makes outgoing requests.
    return await httpClient.GetAsync(&quot;https://weather.com/&quot;);
}
</code></pre><h2 id="trace-outgoing-http-requests-alternative">Trace Outgoing HTTP Requests (alternative)</h2>
<p>Alternatively, if you need to construct <code>HttpClient</code> objects manually,
<code>TraceHeaderPropagatingHandler</code> can be used to propagate trace
headers:</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// Add a handler to trace outgoing requests and to propagate the trace header.
/// The &lt;see cref=&quot;TraceHeaderPropagatingHandler&quot;/&gt; is populated by dependency injection
/// thanks to the use of the &lt;see cref=&quot;FromServicesAttribute&quot;/&gt; attribute.
/// &lt;/summary&gt;
public async Task&lt;HttpResponseMessage&gt; TraceOutgoing([FromServices] TraceHeaderPropagatingHandler traceHeaderHandler)
{
    using (var httpClient = new HttpClient(traceHeaderHandler))
    {
        // Any code that makes outgoing requests.
        return await httpClient.GetAsync(&quot;https://weather.com/&quot;);
    }
}
</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
             
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
