<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Google.Cloud.Spanner.Data | Google.Cloud.Spanner.Data </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Google.Cloud.Spanner.Data | Google.Cloud.Spanner.Data ">
    <meta name="generator" content="docfx 2.39.1.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="googlecloudspannerdata">Google.Cloud.Spanner.Data</h1>

<p><code>Google.Cloud.Spanner.Data</code> is the ADO.NET provider for Cloud Spanner. It is the recommended
package for regular Cloud Spanner database access from .NET.</p>
<p>Note:
This documentation is for version <code>2.1.0</code> of the library.
Some samples may not work with other versions.</p>
<p>The <a href="../Google.Cloud.Spanner.Admin.Instance.V1/">Google.Cloud.Spanner.Admin.Instance.V1</a> package
should be used for Cloud Spanner instance administration, such as creating or deleting instances.</p>
<h1 id="installation">Installation</h1>
<p>Install the <code>Google.Cloud.Spanner.Data</code> package from NuGet. Add it to
your project in the normal way (for example by right-clicking on the
project in Visual Studio and choosing &quot;Manage NuGet Packages...&quot;).</p>
<h1 id="authentication">Authentication</h1>
<p>When running on Google Cloud Platform, no action needs to be taken to authenticate.</p>
<p>Otherwise, the simplest way of authenticating your API calls is to
download a service account JSON file then set the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable to refer to it.
The credentials will automatically be used to authenticate. See the <a href="https://cloud.google.com/docs/authentication/getting-started">Getting Started With
Authentication</a> guide for more details.</p>
<h1 id="getting-started">Getting started</h1>
<p>Operations generally follow ADO.NET conventions.
However Cloud Spanner does not support DML (eg. &quot;INSERT INTO ...&quot;). Therefore you should
use the corresponding API on SpannerConnection to create ADO command objects instead
of setting CommandText manually.</p>
<p>See examples below:</p>
<h1 id="sample-code">Sample code</h1>
<p>Once you have created your Google Cloud Project and Spanner Instance using the web console,
you can start using the ADO.NET provider to create and modify a Cloud Spanner database.</p>
<h2 id="creating-a-database-and-table">Creating a Database and Table</h2>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    SpannerCommand createDbCmd = connection.CreateDdlCommand($&quot;CREATE DATABASE {databaseName}&quot;);
    await createDbCmd.ExecuteNonQueryAsync();

    SpannerCommand createTableCmd = connection.CreateDdlCommand(
        @&quot;CREATE TABLE TestTable (
                                Key                STRING(MAX) NOT NULL,
                                StringValue        STRING(MAX),
                                Int64Value         INT64,
                              ) PRIMARY KEY (Key)&quot;);
    await createTableCmd.ExecuteNonQueryAsync();
}
</code></pre><h2 id="dataadapter-support-net-45-only">DataAdapter support (.NET 4.5+ only)</h2>
<p>Cloud Spanner supports a limited DataAdapter that provides basic CRUD operations on any table.
Create a SpannerDataAdapter with the target table and its primary keys.  You may replace any
commands provided by SpannerDataAdapter with your own custom commands.</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    DataSet untypedDataSet = new DataSet();

    // Provide the name of the Cloud Spanner table and primary key column names.
    SpannerDataAdapter adapter = new SpannerDataAdapter(connection, &quot;TestTable&quot;, &quot;Key&quot;);
    adapter.Fill(untypedDataSet);

    // Insert a row
    DataRow row = untypedDataSet.Tables[0].NewRow();
    row[&quot;Key&quot;] = Guid.NewGuid().ToString(&quot;N&quot;);
    row[&quot;StringValue&quot;] = &quot;New String Value&quot;;
    row[&quot;Int64Value&quot;] = 0L;
    untypedDataSet.Tables[0].Rows.Add(row);

    adapter.Update(untypedDataSet.Tables[0]);
}
</code></pre><h2 id="modifying-data">Modifying data</h2>
<p>Cloud Spanner supports two approaches to modifying data: DML, and direct row modifications.</p>
<h3 id="dml">DML</h3>
<p>DML is capable of affecting multiple rows with a single command. For example, you could delete all
rows matching a query, or update rows to set the value of one column equal to another one.</p>
<p>DML can be executed in standard mode using <code>ExecuteNonQuery</code> or <code>ExecuteNonQueryAsync</code>:</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    // If the transaction is aborted, RunWithRetriableTransactionAsync will
    // retry the whole unit of work with a fresh transaction each time.
    // Please be aware that the whole unit of work needs to be prepared
    // to be called more than once.
    await connection.RunWithRetriableTransactionAsync(async transaction =&gt;
    {
        SpannerCommand cmd = connection.CreateDmlCommand(
            &quot;UPDATE TestTable SET StringValue=&#39;Updated&#39; WHERE Int64Value=@value&quot;);
        cmd.Parameters.Add(&quot;value&quot;, SpannerDbType.Int64, 10);
        cmd.Transaction = transaction;
        int rowsAffected = await cmd.ExecuteNonQueryAsync();
        Console.WriteLine($&quot;{rowsAffected} rows updated...&quot;);
    });
}
</code></pre><p>It is recommended that you execute DML statements within a retriable transaction.
Queries within the same transaction are able to observe the changes already made by DML statements,
and later DML statements can use the values created or updated by earlier ones.
Also, if the transaction is aborted at any point, the whole unit of work will be retried automatically. 
Note that the code executing within a retriable transaction needs to be prepared to be called more
than once.
Please read the <a href="https://cloud.google.com/spanner/docs/reference/rest/v1/TransactionOptions">Cloud Spanner user documentation</a>
for details on when and why transactions can be aborted.</p>
<p>Some DML statements can be executed in a <em>partitioned</em> manner, enabling an efficient
update of large data sets. <code>ExecutePartitionedUpdate</code> or <code>ExecutePartitionedUpdateAsync</code>:</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    SpannerCommand cmd = connection.CreateDmlCommand(
        &quot;UPDATE TestTable SET TestTable.StringValue=&#39;Updated in partitions&#39; WHERE TestTable.Int64Value=@value&quot;);
    cmd.Parameters.Add(&quot;value&quot;, SpannerDbType.Int64, 9);
    long rowsAffected = await cmd.ExecutePartitionedUpdateAsync();
    Console.WriteLine($&quot;{rowsAffected} rows updated...&quot;);
}
</code></pre><p>Partitioned DML updates cannot be performed within another transaction, and have &quot;at least once&quot; semantics:
the update can be applied more than once to a row in some cases, and so is best used with idempotent updates.</p>
<p>Not all DML statements can be partitioned. Please read the Cloud Spanner user documentation for details on
the restrictions.</p>
<h3 id="batch-dml">Batch DML</h3>
<p>Batch DML allows you to execute multiple DML commands in one batched operation.</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    // If the transaction is aborted, RunWithRetriableTransactionAsync will
    // retry the whole unit of work with a fresh transaction each time.
    // Please be aware that the whole unit of work needs to be prepared
    // to be called more than once.
    await connection.RunWithRetriableTransactionAsync(async (transaction) =&gt;
    {
        SpannerBatchCommand cmd = transaction.CreateBatchDmlCommand();

        cmd.Add(
            &quot;UPDATE TestTable SET StringValue=&#39;Updated&#39; WHERE Int64Value=@value&quot;,
            new SpannerParameterCollection { { &quot;value&quot;, SpannerDbType.Int64, 5 } });

        cmd.Add(
            &quot;DELETE FROM TestTable WHERE Int64Value=@value&quot;,
            new SpannerParameterCollection { { &quot;value&quot;, SpannerDbType.Int64, 250 } });

        IEnumerable&lt;long&gt; rowsAffected = await cmd.ExecuteNonQueryAsync();
        Console.WriteLine($&quot;{rowsAffected.ElementAt(0)} rows updated...&quot;);
        Console.WriteLine($&quot;{rowsAffected.ElementAt(1)} rows deleted...&quot;);
    });
}
</code></pre><p>Statements are executed sequentally in the same order they are provided. Changes made by one statement are
visible to all subsequent statements in the batch.</p>
<p>When one of the statemens in the batch fails, execution is halted and all subsequent statements are not
executed. A <code>SpannerBatchNonQueryException</code> will be thrown that contains both information about the error
and the number of rows affected by each of the statements that executed before the failed one. If you are executing
the batch DML command inside a non-retriable transaction you can simply commit the transaction when <code>SpannerBatchNonQueryException</code>
is thrown if partial success is acceptable in your application.
It is recommended to run Batch DML within a retriable transaction. If the transaction
aborts the whole unit of work will be retried automatically.
Note that the code executing within a retriable transaction needs to be prepared to be called more
than once.
Please read the <a href="https://cloud.google.com/spanner/docs/reference/rest/v1/TransactionOptions">Cloud Spanner user documentation</a>
for details on when and why transactions can be aborted.</p>
<h3 id="direct-row-modifications">Direct row modifications</h3>
<p>The following operations are supported for direct row modification:</p>
<ul>
<li>Insert</li>
<li>Update</li>
<li>Delete</li>
<li>Insert or update (also known as &quot;upsert&quot;)</li>
</ul>
<p>Create a command from the <code>SpannerConnection</code>, providing the table name to the appropriate method
(<code>CreateInsertCommand</code> and the like), then use the command parameters to specify values for columns.
The command can be reused to perform the same kind of operation for multiple rows.</p>
<p>This sample inserts two rows, then reads them again:</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    // If the transaction is aborted, RunWithRetriableTransactionAsync will
    // retry the whole unit of work with a fresh transaction each time.
    await connection.RunWithRetriableTransactionAsync(async transaction =&gt;
    {
        SpannerCommand cmd = connection.CreateInsertCommand(&quot;TestTable&quot;);
        SpannerParameter keyParameter = cmd.Parameters.Add(&quot;Key&quot;, SpannerDbType.String);
        SpannerParameter stringValueParameter = cmd.Parameters.Add(&quot;StringValue&quot;, SpannerDbType.String);
        SpannerParameter int64ValueParameter = cmd.Parameters.Add(&quot;Int64Value&quot;, SpannerDbType.Int64);
        cmd.Transaction = transaction;

        // This executes 5 distinct insert commands using the retriable transaction.
        // The mutations will be effective once the transaction has committed successfully.
        for (int i = 0; i &lt; 5; i++)
        {
            keyParameter.Value = Guid.NewGuid().ToString(&quot;N&quot;);
            stringValueParameter.Value = $&quot;StringValue{i}&quot;;
            int64ValueParameter.Value = i;
            int rowsAffected = await cmd.ExecuteNonQueryAsync();
            Console.WriteLine($&quot;{rowsAffected} rows written...&quot;);
        }
    });
}
</code></pre><p>This sample reads three keys using a <code>SELECT</code> command, updates a row using an <code>UPDATE</code> command, then
deletes a row using a <code>DELETE</code> command:</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    // If the transaction is aborted, RunWithRetriableTransactionAsync will
    // retry the whole unit of work with a fresh transaction each time.
    // Please be aware that the whole unit of work needs to be prepared
    // to be called more than once.
    await connection.RunWithRetriableTransactionAsync(async (transaction) =&gt;
    {

        // Read the first two keys in the database.
        List&lt;string&gt; keys = new List&lt;string&gt;();
        SpannerCommand selectCmd = connection.CreateSelectCommand(&quot;SELECT * FROM TestTable&quot;);
        using (SpannerDataReader reader = await selectCmd.ExecuteReaderAsync())
        {
            while (keys.Count &lt; 3 &amp;&amp; await reader.ReadAsync())
            {
                keys.Add(reader.GetFieldValue&lt;string&gt;(&quot;Key&quot;));
            }
        }

        // Update the Int64Value of keys[0]
        // Include the primary key and update columns.
        SpannerCommand updateCmd = connection.CreateUpdateCommand(&quot;TestTable&quot;);
        updateCmd.Parameters.Add(&quot;Key&quot;, SpannerDbType.String, keys[0]);
        updateCmd.Parameters.Add(&quot;Int64Value&quot;, SpannerDbType.Int64, 0L);
        await updateCmd.ExecuteNonQueryAsync();

        // Delete row for keys[1]
        SpannerCommand deleteCmd = connection.CreateDeleteCommand(&quot;TestTable&quot;);
        deleteCmd.Parameters.Add(&quot;Key&quot;, SpannerDbType.String, keys[1]);
        await deleteCmd.ExecuteNonQueryAsync();
    });
</code></pre><p>When direct row modifications are performed in a transaction, they are only applied when the transaction is committed.
Queries within the transaction will not observe any changes.
It is recommended to run direct row modifications within a retriable transaction. If the transaction
aborts the whole unit of work will be retried automatically.
Note that the code executing within a retriable transaction needs to be prepared to be called more
than once.
Please read the <a href="https://cloud.google.com/spanner/docs/reference/rest/v1/TransactionOptions">Cloud Spanner user documentation</a>
for details on when and why transactions can be aborted.</p>
<h3 id="using-a-commit-timestamp">Using a commit timestamp</h3>
<p>Spanner allows you to write a commit timestamp for insert and update
operations.</p>
<p>When using direct row modifications, the commit timestamp can be set
using <code>SpannerParameter.CommitTimestamp</code> as the value for a
parameter, as shown below.</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    string createTableStatement =
        @&quot;CREATE TABLE UsersHistory (
        Id INT64 NOT NULL,
        CommitTs TIMESTAMP NOT NULL OPTIONS
            (allow_commit_timestamp=true),
        Name STRING(MAX) NOT NULL,
        Email STRING(MAX),
        Deleted BOOL NOT NULL,
        ) PRIMARY KEY(Id, CommitTs DESC)&quot;;

    await connection.CreateDdlCommand(createTableStatement).ExecuteNonQueryAsync();

    // Create a command for inserting rows.
    SpannerCommand cmd = connection.CreateInsertCommand(&quot;UsersHistory&quot;,
        new SpannerParameterCollection
        {
            { &quot;Id&quot;, SpannerDbType.Int64 },
            { &quot;CommitTs&quot;, SpannerDbType.Timestamp, SpannerParameter.CommitTimestamp },
            { &quot;Name&quot;, SpannerDbType.String },
            { &quot;Deleted&quot;, SpannerDbType.Bool , false}
        });

    int rowsAffected = 0;

    // If the transaction is aborted, RunWithRetriableTransactionAsync will
    // retry the whole unit of work with a fresh transaction each time.
    // Please be aware that the whole unit of work needs to be prepared
    // to be called more than once.
    await connection.RunWithRetriableTransactionAsync(async transaction =&gt;
    {
        // Insert a first row
        cmd.Parameters[&quot;Id&quot;].Value = 10L;
        cmd.Parameters[&quot;Name&quot;].Value = &quot;Demo 1&quot;;
        cmd.Transaction = transaction;
        rowsAffected += await cmd.ExecuteNonQueryAsync();
    });

    await connection.RunWithRetriableTransactionAsync(async transaction =&gt;
    {
        // Insert a second row
        cmd.Parameters[&quot;Id&quot;].Value = 11L;
        cmd.Parameters[&quot;Name&quot;].Value = &quot;Demo 2&quot;;
        rowsAffected += await cmd.ExecuteNonQueryAsync();
    });

    Console.WriteLine($&quot;{rowsAffected} rows written...&quot;);

    // Display the inserted values
    SpannerCommand selectCmd = connection.CreateSelectCommand(&quot;SELECT * FROM UsersHistory&quot;);
    using (SpannerDataReader reader = await selectCmd.ExecuteReaderAsync())
    {
        while (await reader.ReadAsync())
        {
            long id = reader.GetFieldValue&lt;long&gt;(&quot;Id&quot;);
            string name = reader.GetFieldValue&lt;string&gt;(&quot;Name&quot;);
            DateTime timestamp = reader.GetFieldValue&lt;DateTime&gt;(&quot;CommitTs&quot;);
            Console.WriteLine($&quot;{id}: {name} - {timestamp:HH:mm:ss.ffffff}&quot;);
        }
    }
}
</code></pre><p>This parameter value cannot be used in DML. Instead, use the
<code>PENDING_COMMIT_TIMESTAMP()</code> function in your DML statement.</p>
<p>See the <a href="https://cloud.google.com/spanner/docs/commit-timestamp">Cloud Spanner
documentation</a>
for more information about commit timestamps.</p>
<h2 id="transactions-and-fault-handling">Transactions and Fault Handling</h2>
<p>Cloud Spanner is fully ACID compliant.</p>
<p>Retries should be implemented at the transaction level (as opposed to individual call level)
because there is a chance in high stress situations that a Cloud Spanner session (transaction)
can be aborted due to causing a deadlock. In this case, the entire transaction should be
retried. The methods <code>SpannerConnection.RunWithRetriableTransactionAsync(...)</code> will take care of
automatically retrying the entire callback passed as a paremeter using a fresh transaction
if previous attempts aborted.</p>
<ul>
<li>The callback doesn&#39;t need to handle the transaction lifecycle.</li>
<li>The callback needs to set the transaction received on all the commands it creates.</li>
<li>The callback might be called more than once, so the code should be written bearing this in mind.</li>
</ul>
<p>Please read the <a href="https://cloud.google.com/spanner/docs/reference/rest/v1/TransactionOptions">Cloud Spanner user documentation</a>
for details on when and why transactions can be aborted.</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.OpenAsync();

    // If the transaction is aborted, RunWithRetriableTransactionAsync will
    // retry the whole unit of work with a fresh transaction each time.
    await connection.RunWithRetriableTransactionAsync(async transaction =&gt;
    {
        SpannerCommand cmd = connection.CreateInsertCommand(&quot;TestTable&quot;);
        SpannerParameter keyParameter = cmd.Parameters.Add(&quot;Key&quot;, SpannerDbType.String);
        SpannerParameter stringValueParameter = cmd.Parameters.Add(&quot;StringValue&quot;, SpannerDbType.String);
        SpannerParameter int64ValueParameter = cmd.Parameters.Add(&quot;Int64Value&quot;, SpannerDbType.Int64);
        cmd.Transaction = transaction;

        // This executes 5 distinct insert commands using the retriable transaction.
        // The mutations will be effective once the transaction has committed successfully.
        for (int i = 0; i &lt; 5; i++)
        {
            keyParameter.Value = Guid.NewGuid().ToString(&quot;N&quot;);
            stringValueParameter.Value = $&quot;StringValue{i}&quot;;
            int64ValueParameter.Value = i;
            int rowsAffected = await cmd.ExecuteNonQueryAsync();
            Console.WriteLine($&quot;{rowsAffected} rows written...&quot;);
        }
    });
}
</code></pre><h2 id="session-pool-management">Session pool management</h2>
<p><code>Google.Cloud.Spanner.Data</code> manages Spanner sessions for you via a
session pool. The pool has various <a href="configuration.html">configuration
options</a>, but additionally you may wish to take
advantage of additional <code>SpannerConnection</code> methods at the start and
end of your application.</p>
<p>To ensure that the session pool is populated with the configured
minimum number of sessions before serving requests from your
application, you may wish to wait for the task returned by
<code>SpannerConnection.WhenSessionPoolReady()</code> to complete before
marking your application as &quot;ready to serve&quot;.</p>
<pre><code class="lang-cs">// This would usually be executed during application start-up, before any Spanner
// operations are performed. It can be used at any time, however. It is purely passive:
// it doesn&#39;t modify the session pool or trigger any other actions.
using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.WhenSessionPoolReady();
}
</code></pre><p>When your application is shutting down, you may wish to delete the
sessions it has been using from the server. Most applications will
not need to do this: sessions automatically expire after an idle
time of an hour anyway, and the server-enforced session limit is
high. Applications using a large number of sessions may wish to
clean up sessions more actively, however. Again, <code>SpannerConnection</code>
provides a simple method to accomplish this:</p>
<pre><code class="lang-cs">// When your application is shutting down. Note that any pending or future requests
// for sessions will fail.
using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    await connection.ShutdownSessionPoolAsync();
}
</code></pre><p>If you want to diagnose session management issues,
<code>SpannerConnection</code> provides a method to fetch a snapshot of
the statistics for the session pool associated with the database
associated with the connection:</p>
<pre><code class="lang-cs">using (SpannerConnection connection = new SpannerConnection(connectionString))
{
    SessionPool.DatabaseStatistics stats = connection.GetSessionPoolDatabaseStatistics();
    if (stats is null)
    {
        Console.WriteLine(&quot;No session pool for this connection string yet&quot;);
    }
    else
    {
        // Access individual properties...
        Console.WriteLine($&quot;Database name: {stats.DatabaseName}&quot;);
        Console.WriteLine($&quot;Active sessions: {stats.ActiveSessionCount}&quot;);
        Console.WriteLine($&quot;Pooled read-only sessions: {stats.ReadPoolCount}&quot;);
        Console.WriteLine($&quot;Pooled read-write sessions: {stats.ReadWritePoolCount}&quot;);
        // ... or just use the overridden ToString method to log all the statistics in one go:
        Console.WriteLine(stats);
    }
}
</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
             
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
