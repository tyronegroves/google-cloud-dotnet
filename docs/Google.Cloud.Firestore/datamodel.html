<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Data model | Google.Cloud.Firestore </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Data model | Google.Cloud.Firestore ">
    <meta name="generator" content="docfx 2.39.1.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="data-model">Data model</h1>

<p>The Firestore data model revolves around <em>documents</em> and <em>collections</em>.</p>
<p>Collections contain documents, which can contain more collections. The document data itself doesn&#39;t contain subcollections,
although it can contain nested data.</p>
<p>The Firestore library for .NET provides multiple options for working with Firestore data.
It aims to make it simple for you to work with the data, whether you&#39;re creating, updating or querying it.</p>
<p>This page is primarily aimed at explaining how document data can be used with the .NET library. See
the <a href="userguide.html">user guide</a> for more details around the relationship between documents and collections.</p>
<h1 id="data-types">Data types</h1>
<p>A document is essentially a map, from field names to field values. Firestore supports multiple types of data for fields.
For interoperability, some Firestore data types map onto multiple .NET types. The table below shows these types, and the default .NET
type that a value will be deserialized as, when no other information is available.</p>
<table>
  <thead>
    <tr>
      <th>Firestore data type</th>
      <th>.NET supported types</th>
      <th>Default type</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Array</td>
      <td>Any <code>IEnumerable&lt;T&gt;</code></td>
      <td><code>List&lt;object&gt;</code></td>
      <td>Array elements cannot themselves be arrays</td>
    </tr>
    <tr>
      <td>Boolean</td>
      <td><code>bool</code></td>
      <td><code>bool</code></td>
      <td></td>
    </tr>
    <tr>
      <td>Bytes</td>
      <td>
        <code><a href="api/Google.Cloud.Firestore.Blob.html">Google.Cloud.Firestore.Blob</a></code><br>
        <code>byte[]</code><br>
        <code>Google.Protobuf.ByteString</code>
      </td>
      <td><code>Google.Cloud.Firestore.Blob</code></td>
      <td>Up to 1,048,487 bytes (1 MiB - 89 bytes). Only the first 1,500 bytes are considered by queries.</td>
    </tr>
    <tr>
      <td>Date and time</td>
      <td>
        <code><a href="api/Google.Cloud.Firestore.Timestamp.html">Google.Cloud.Firestore.Timestamp</a></code><br>
        <code>System.DateTime</code><br>
        <code>System.DateTimeOffset</code><br>
        <code>Google.Protobuf.WellKnownTypes.Timestamp</code>
      </td>
      <td><code>Google.Cloud.Firestore.Timestamp</code></td>
      <td>When stored in Cloud Firestore, precise only to microseconds; any additional precision is rounded down. <code>DateTime</code>
        values must have a <code>Kind</code> of <code>Utc</code> to be converted; <code>DateTimeOffset</code> values are converted
        to UTC automatically, and the offset information is discarded.</td>
    </tr>
    <tr>
      <td>Floating-point number</td>
      <td><code>double</code>, <code>float</code>, integer types listed below</td>
      <td><code>double</code></td>
      <td>64-bit double precision, IEEE 754. Floating point values are permitted to be deserialized<br>      as integer values for compatibility with platforms which do not distinguish between
      floating point values and integer values.</td>
    </tr>
    <tr>
      <td>Geographical point</td>
      <td>
        <code><a href="api/Google.Cloud.Firestore.GeoPoint.html">Google.Cloud.Firestore.GeoPoint</a></code><br>
        <code>Google.Type.LatLng</code>
      </td>
      <td><code>Google.Cloud.Firestore.GeoPoint</code></td>
      <td></td>
    </tr>
    <tr>
      <td>Integer</td>
      <td>Any integer type (<code>byte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>long</code> etc) or enum type; <code>float</code> and <code>double</code></td>
      <td><code>long</code></td>
      <td>Signed 64-bit integer. When deserializing from server data, if the value is outside the range of the target type,
        <code>OverflowException</code> is thrown. Similarly, an <code>OverflowException</code> will
        be thrown if a <code>ulong</code> value outside the range of <code>long</code> is serialized.
        Integer values are permitted to be deserialized as <code>float</code> and <code>double</code>
        values for compatibility with platforms which do not distinguish between floating point
        values and integer values.</td>
    </tr>
    <tr>
      <td>Map</td>
      <td>Any <code>IDictionary&lt;string, TValue&gt;</code>, anonymous type or attributed-class (see later)</td>
      <td><code>Dictionary&lt;string, object&gt;</code></td>
      <td>Represents an object embedded within a document. When indexed, you can query on subfields. If you exclude this value from indexing, then all subfields are also excluded from indexing.
      C# 7 value tuples are also supported in a limited set of contexts. See <a href="#value-tuples">the section below</a> for more details.</td>
    </tr>
    <tr>
      <td>Null</td>
      <td>Null reference</td>
      <td>n/a</td>
      <td></td>
    </tr>
    <tr>
      <td>Reference</td>
      <td><code><a href="api/Google.Cloud.Firestore.DocumentReference.html">Google.Cloud.Firestore.DocumentReference</a></code></td>
      <td><code>Google.Cloud.Firestore.DocumentReference</code></td>
      <td></td>
    </tr>
    <tr>
      <td>Text</td>
      <td><code>string</code></td>
      <td><code>string</code></td>
      <td>Sort order is in UTF-8 representation</td>
    </tr>
  </tbody>
</table>

<p>The &quot;name to value&quot; map can be represented in multiple ways. The following sections demonstrate each approach. Note that map values can be nested,
and you can mix and match approaches. For example, an attributed class can contain a dictionary or vice versa.
Similarly, you can serialize as an anonymous type then deserialize as an attributed class.</p>
<h2 id="mapping-with-attributed-classes">Mapping with attributed classes</h2>
<p>If you apply the <a href="api/Google.Cloud.Firestore.FirestoreDataAttribute.html">FirestoreData</a> attribute to a class, the Firestore library for .NET can use it for serialization (when sending data to the server)
and deserialization (when retrieving data). All public instance properties with the <a href="api/Google.Cloud.Firestore.FirestorePropertyAttribute.html">FirestoreProperty</a> attribute applied are serialized.</p>
<p>For example, to model a city as a document, you might have a class like this:</p>
<pre><code class="lang-cs">[FirestoreData]
public class City
{
    [FirestoreProperty]
    public string Name { get; set; }

    [FirestoreProperty]
    public string State { get; set; }

    [FirestoreProperty]
    public string Country { get; set; }

    [FirestoreProperty(&quot;Capital&quot;)]
    public bool IsCapital { get; set;  }

    [FirestoreProperty]
    public long Population { get; set; }
}
</code></pre><p>Note how the <code>IsCapital</code> property specifies the name in the attribute; this is the field name that will be in the stored document.
This allows you to use idiomatic names in your .NET code, but match whatever field name is used in your Firestore database.</p>
<p>You might then use it to create a document and then fetch it like this:</p>
<pre><code class="lang-cs">FirestoreDb db = FirestoreDb.Create(projectId);

// Create a document with a random ID in the &quot;cities&quot; collection.
CollectionReference collection = db.Collection(&quot;cities&quot;);
City city = new City
{
    Name = &quot;Los Angeles&quot;,
    Country = &quot;USA&quot;,
    State = &quot;CA&quot;,
    IsCapital = false,
    Population = 3900000L
};
DocumentReference document = await collection.AddAsync(city);

// Fetch the data back from the server and deserialize it.
DocumentSnapshot snapshot = await document.GetSnapshotAsync();
City citySnapshot = snapshot.ConvertTo&lt;City&gt;();
Console.WriteLine(citySnapshot.Name); // Los Angeles
</code></pre><p>In order to deserialize a map as an attributed class, the class must have a public parameterless constructor. (The C# compiler provides
one by default if no other constructors are specified.) The properties in the map must each have an attributed instance property with a setter,
and the type of the property must be suitable for the value in the map. If the attributed class doesn&#39;t have a suitable property for an element of the map,
an exception is thrown.</p>
<p>Four additional attributes are also available for attributed
classes. The attributed properties play no part in serializing data
when writing to Firestore, but are automatically populated when
deserializing a document snapshot.</p>
<ul>
<li><a href="api/Google.Cloud.Firestore.FirestoreDocumentIdAttribute.html">FirestoreDocumentId</a></li>
<li><a href="api/Google.Cloud.Firestore.FirestoreDocumentCreateTimestampAttribute.html">FirestoreDocumentCreateTimestamp</a></li>
<li><a href="api/Google.Cloud.Firestore.FirestoreDocumentUpdateTimestampAttribute.html">FirestoreDocumentUpdateTimestamp</a></li>
<li><a href="api/Google.Cloud.Firestore.FirestoreDocumentReadTimestampAttribute.html">FirestoreDocumentReadTimestamp</a></li>
</ul>
<p><code>FirestoreDocumentId</code> must be placed on a property of type <code>string</code>
or <code>DocumentReference</code>. If the property is of type <code>string</code>, it is
populated with the document ID. If the property is of type
<code>DocumentReference</code>, it is populated with the complete reference to
the document.</p>
<p>Each timestamp attribute must be placed on a <code>DateTime</code>,
<code>DateTimeOffset</code>, <code>Google.Cloud.Firestore.Timestamp</code> or
<code>Google.Protobuf.WellKnownTypes.Timestamp</code> property. (Properties of
nullable types are also permitted.)</p>
<p>For example, consider the following data model:</p>
<pre><code class="lang-cs">[FirestoreData]
public class ChatRoom
{
    [FirestoreDocumentId]
    public DocumentReference Reference { get; set; }

    [FirestoreDocumentCreateTimestamp]
    public Timestamp CreateTime { get; set; }

    [FirestoreDocumentUpdateTimestamp]
    public Timestamp UpdateTime { get; set; }

    [FirestoreDocumentReadTimestamp]
    public Timestamp ReadTime { get; set; }

    [FirestoreProperty]
    public string Name { get; set; }

    [FirestoreProperty]
    public bool Public { get; set; }
}
</code></pre><p>The following code creates a document for a chat room, then later fetches it.</p>
<pre><code class="lang-cs">string projectId = _fixture.ProjectId;
FirestoreDb db = FirestoreDb.Create(projectId);

// Create a document with a random ID in the &quot;rooms&quot; collection.
CollectionReference collection = db.Collection(&quot;rooms&quot;);
DocumentReference document = await collection.AddAsync(new ChatRoom { Name = &quot;Jon&#39;s private chat&quot; });

// Later in code, fetch a snapshot (potentially using a query; we&#39;re fetching directly for simplicity)
DocumentSnapshot snapshot = await document.GetSnapshotAsync();
ChatRoom room = snapshot.ConvertTo&lt;ChatRoom&gt;();
// room.Reference is now populated with the document reference,
// room.CreateTime is populated with the time the document was created,
// room.UpdateTime is populated with the time the document was updated,
// room.ReadTime is populated with the time the document snapshot was read.
</code></pre><p>Without the attributes, the document reference and timestamps would
still be available to the code that deserializes the snapshot, but
other code using the <code>ChatRoom</code> object later wouldn&#39;t have access to
them without extra code to populate it. The attributes just allows
you to populate this information in your model without any additional code.</p>
<p><strong>Note</strong>: The <code>FirestoreData</code> attribute can be applied to a struct
as well, but this only makes sense for mutable structs - which are
generally discouraged. The struct will be boxed as part of
serialization and deserialization, so there&#39;s no memory advantage
in that sense. However, this is supported for the sake of code which
wishes to use mutable structs for other reasons elsewhere.
To support immutable structs (which are generally prefered), write
a <a href="#custom-converters">custom converter</a> in the same way as you
would for a class.</p>
<h2 id="mapping-with-dictionaries">Mapping with dictionaries</h2>
<p>A map can be represented as a <code>Dictionary&lt;string, object&gt;</code> - or if you&#39;re only storing values of a particular type, a <code>Dictionary&lt;string, int&gt;</code>, <code>Dictionary&lt;string, string&gt;</code> etc.
The key type for the dictionary must always be <code>string</code>, as the Firestore field name is used as the key.</p>
<p>Dictionaries can be passed to the various document creation and modification methods to represent the data, and <code>DocumentSnapshot.ToDictionary</code> deserializes
document data to a dictionary representation.</p>
<p>The equivalent city code using dictionaries would look like this:</p>
<pre><code class="lang-cs">FirestoreDb db = FirestoreDb.Create(projectId);

// Create a document with a random ID in the &quot;cities&quot; collection.
CollectionReference collection = db.Collection(&quot;cities&quot;);
Dictionary&lt;string, object&gt; city = new Dictionary&lt;string, object&gt;
{
    { &quot;Name&quot;, &quot;Los Angeles&quot; },
    { &quot;Country&quot;, &quot;USA&quot; },
    { &quot;State&quot;, &quot;CA&quot; },
    { &quot;Capital&quot;, false },
    { &quot;Population&quot;, 3900000L }
};
DocumentReference document = await collection.AddAsync(city);

// Fetch the data back from the server and deserialize it.
DocumentSnapshot snapshot = await document.GetSnapshotAsync();
Dictionary&lt;string, object&gt; cityData = snapshot.ToDictionary();
Console.WriteLine(cityData[&quot;Name&quot;]); // Los Angeles
</code></pre><h2 id="mapping-with-anonymous-types">Mapping with anonymous types</h2>
<p>Anonymous types can be used for serialization, but not deserialization. They are particularly useful to specify partial updates, or
to populate data which isn&#39;t then read within the same codebase.</p>
<pre><code class="lang-cs">FirestoreDb db = FirestoreDb.Create(projectId);

// Create a document with a random ID in the &quot;cities&quot; collection.
CollectionReference collection = db.Collection(&quot;cities&quot;);
var city = new
{
    Name = &quot;Los Angeles&quot;,
    Country = &quot;USA&quot;,
    State = &quot;CA&quot;,
    Capital = false,
    Population = 3900000L
};
DocumentReference document = await collection.AddAsync(city);

// Update just the population using another anonymous type
await document.SetAsync(new { Population = 3900005L }, SetOptions.MergeAll);

// Fetch the latest document and print the population
DocumentSnapshot snapshot = await document.GetSnapshotAsync();
Console.WriteLine(snapshot.GetValue&lt;long&gt;(&quot;Population&quot;)); // 3900005
</code></pre><h2 id="custom-converters">Custom converters</h2>
<p>If the built-in conversions aren&#39;t flexible enough for your needs,
you can create a custom converter implementing
<code>IFirestoreConverter&lt;T&gt;</code>:</p>
<pre><code class="lang-csharp">public interface IFirestoreConverter&lt;T&gt;
{
    object ToFirestore(T value);
    T FromFirestore(object value);
}
</code></pre><p>The <code>ToFirestore</code> method should convert the <code>T</code> value into a
suitable format to be stored. This can use any of the conversions
described above. For example, if the method returns an <code>int</code>, the
value will be stored as a 64-bit integer in the same way as an <code>int</code>
property in an attributed type, or an <code>int</code> value within a dictionary.</p>
<p>The <code>FromFirestore</code> method receives the deserialized value using the
default mapping, as shown in the earlier table.</p>
<h3 id="applying-a-converter-to-a-type">Applying a converter to a type</h3>
<p>Once you&#39;ve created a converter, you can either apply it to a type
or an individual attributed property. In each case, the
<code>ConverterType</code> property is specified in the attribute.</p>
<p>For example, suppose you wish to create several ID classes or
structs, each containing a string of the underlying ID. This is a
technique sometimes used to effectively make type-safe identifiers.
You could create a converter for each class, and apply the
<code>[FirestoreData]</code> attribute to each class, specifying the
corresponding converter. This would allow each ID to be stored as
just the string, rather than as a map containing a single element with
a string value. The following example demonstrates this with a
<code>PlayerId</code> class. If another attributed class (e.g. a <code>Game</code>) had a
<code>PlayerId</code> property, the converter would be used automatically.</p>
<pre><code class="lang-cs">/// &lt;summary&gt;
/// A domain representation of a player ID. This can be used in other attributed
/// classes, and the PlayerIdConverter methods will be called for any PlayerId
/// properties with the FirestoreProperty attribute.
/// &lt;/summary&gt;
[FirestoreData(ConverterType = typeof(PlayerIdConverter))]
public class PlayerId
{
    public string Id { get; }

    public PlayerId(string id)
    {
        Id = id;
    }
}

public class PlayerIdConverter : IFirestoreConverter&lt;PlayerId&gt;
{
    // A PlayerId should be represented in storage as just the string value.
    public object ToFirestore(PlayerId value) =&gt; value.Id;

    public PlayerId FromFirestore(object value)
    {
        switch (value)
        {
            // This is the expected path: 
            case string id:
                return new PlayerId(id);
            // The converter will never be called with a null value from Google.Cloud.Firestore,
            // but throw an appropriate exception anyway.
            case null:
                throw new ArgumentNullException(nameof(value));
            // The converter may be called with unexpected data if (say) there&#39;s a document stored
            // with a field of the wrong type.
            default:
                throw new ArgumentException($&quot;Invalid type to convert to PlayerId: {value.GetType()}&quot;);
        }
    }
}
</code></pre><h3 id="applying-a-converter-to-a-property">Applying a converter to a property</h3>
<p>Sometimes you may want to perform custom conversions for types that
you can&#39;t apply attributes to, or you may want different conversions
in different situations. In that case, you can implement the
converter in the same way, but apply it selectively using the
<code>ConverterType</code> property on the <code>[FirestoreProperty]</code> attribute
instead.</p>
<p>As an example, you may want to use the .NET <code>Guid</code> struct within
your data model. You could store each <code>Guid</code> property as a string,
using the following sample code.</p>
<pre><code class="lang-cs">[FirestoreData]
public class PlayerWithGuidId
{
    [FirestoreProperty(ConverterType = typeof(GuidConverter))]
    public Guid Id { get; set; }

    [FirestoreProperty]
    public DateTime LastPlayed { get; set; }

    [FirestoreProperty]
    public int HighScore { get; set; }
}

public class GuidConverter : IFirestoreConverter&lt;Guid&gt;
{
    public object ToFirestore(Guid value) =&gt; value.ToString(&quot;N&quot;);

    public Guid FromFirestore(object value)
    {
        switch (value)
        {
            case string guid: return Guid.ParseExact(guid, &quot;N&quot;);
            case null: throw new ArgumentNullException(nameof(value));
            default: throw new ArgumentException($&quot;Unexpected data: {value.GetType()}&quot;);
        }
    }
}
</code></pre><h3 id="converter-registries">Converter registries</h3>
<p>In some cases, you may wish to apply custom conversions without any
ability to add attributes to types or properties. In this situation,
you can build a <code>FirestoreDb</code> with a converter registry to specify
which custom converters you want to be applied by default. This
can be done via <code>FirestoreDbBuilder</code>, which has a <code>ConverterRegistry</code>
property.</p>
<p>For example, instead of specifying the converter on the
<code>PlayerWithGuidId.Id</code> property in the sample above, the converter could
be registered in the <code>FirestoreDb</code> instead:</p>
<pre><code class="lang-cs">FirestoreDb db = new FirestoreDbBuilder
{
    ProjectId = projectId,
    ConverterRegistry = new ConverterRegistry
    {
        new GuidConverter()
    }
}.Build();
// Documents serialized and deserialized via db will now use the
// custom Guid converter.
</code></pre><h3 id="document-converters">Document converters</h3>
<p>If you wish a .NET type to be stored as a complete document after
custom conversion, the converter must return a value which would be
serialized as a map. This could be a dictionary, an anonymous type,
or even a separate attributed type. When deserializing, the
converter will receive an <code>IDictionary&lt;string, object&gt;</code> which it
should use to extract the original data.</p>
<pre><code class="lang-cs">[FirestoreData(ConverterType = typeof(CustomCityConverter))]
public class CustomCity
{
    // Note: no [FirestoreProperty] attributes. The converter
    // is doing all the work.
    public string Name { get; }
    public string Country { get; }
    public long Population { get; }

    public CustomCity(string name, string country, long population)
    {
        Name = name;
        Country = country;
        Population = population;
    }
}

public class CustomCityConverter : IFirestoreConverter&lt;CustomCity&gt;
{
    // An anonymous type is a convenient way of serializing a map value.
    // You could create a Dictionary&lt;string, object&gt; instead; they&#39;re stored the
    // same way.
    public object ToFirestore(CustomCity value) =&gt;
        new { value.Name, value.Country, value.Population };

    public CustomCity FromFirestore(object value)
    {
        if (value is IDictionary&lt;string, object&gt; map)
        {
            // Any exceptions thrown here will be propagated directly. You may wish to be more
            // careful, if you need to control the exact exception thrown used when the
            // data is incomplete or has the wrong type.
            return new CustomCity((string) map[&quot;Name&quot;], (string) map[&quot;Country&quot;], (long) map[&quot;Population&quot;]);
        }
        throw new ArgumentException($&quot;Unexpected data: {value.GetType()}&quot;);
    }
}
</code></pre><h3 id="null-values-and-custom-converters">Null values and custom converters</h3>
<p>Note that the conversion methods never receive null references, nor should
they return null values. While it would be possible to deserialize
null values to non-null .NET values, the conversion used in
serialization is usually determined based on the actual type of the
value being serialized. The approach used for null values ensures
consistency.</p>
<p>As a side-effect of this decision, it is advisable for the type
argument of <code>IFirestoreConverter</code> to be a class or a non-nullable
value type. For example, implement <code>IFirestoreConverter&lt;Guid&gt;</code>
rather than <code>IFirestoreConverter&lt;Guid?&gt;</code>. If a converter is supplied
for a non-nullable value type, the converter will automatically be
used for the corresponding nullable value type too, with null values
being handled transparently.</p>
<h2 id="enum-conversions">Enum conversions</h2>
<p>By default, C# enum values are converted to their underlying integer
values. The Google.Cloud.Firestore package includes a custom converter
that can be specified in the same way as any other custom converter, in
order to convert between enum values and their names instead.</p>
<p>The example below applies the converter on the enum itself, effectively
changing the default serialization model for that enum. The converter
could equally be applied on a property or registered in the converter
registry for the <code>FirestoreDb</code> used to create and retrieve documents.</p>
<pre><code class="lang-cs">[FirestoreData(ConverterType = typeof(FirestoreEnumNameConverter&lt;SerializedByName&gt;))]
public enum SerializedByName
{
    None,
    FirstValue,
    SecondValue
}
</code></pre><h1 id="value-tuples">Value tuples</h1>
<p>C# 7 introduced a feature around the <code>System.ValueTuple</code> generic structs which are part of
the framework. When using <a href="#mapping-with-attributed-classes">attributed properties</a>, the built-in
converters will serialize tuples as if they were a dictionary from the tuple element names to their values.</p>
<p>Consider the following class:</p>
<pre><code class="lang-cs">[FirestoreData]
public class Company
{
    [FirestoreProperty]
    public string Name { get; set; }

    [FirestoreProperty]
    public (string city, string state, string country) Location { get; set; }
}
</code></pre><p>A document representing a <code>Company</code> will be serialized as a top-level map with <code>Name</code> and <code>Location</code> fields;
the <code>Location</code> field will itself be a map with <code>city</code>, <code>state</code> and <code>country</code> fields.</p>
<p>There are some limitations on this feature:</p>
<ul>
<li>The feature only applies to attributed properties, not types in dictionaries,
anonymous types etc.</li>
<li>All tuple elements must be named. A tuple type of <code>(string name, int)</code> would be invalid, for example.</li>
<li>The property type must be either the tuple type or the nullable equivalent. For example, a property
with a type of <code>List&lt;(string name, int value)&gt;</code> would not be valid.</li>
<li>Only tuples with up to 7 elements are supported.</li>
</ul>
<p>These restrictions primarily exist for simplicity of the implementation, and the feature may be expanded
later to lift some of them.</p>
<h1 id="sentinel-values">Sentinel values</h1>
<p>So far all the values we&#39;ve looked at have been known by the C# code. There are additional <em>sentinel values</em> available which behave slightly differently.</p>
<h2 id="server-side-timestamp">Server-side timestamp</h2>
<p>When you update a document using the server-side timestamp sentinel value, the actual timestamp that&#39;s recorded is the commit time
according to the Firestore server.</p>
<p>For attributed classes, you can specify <code>ServerTimestamp</code> in the attribute declaration for the property. Usually
this will be on a property of type <code>Timestamp</code> (or <code>DateTime</code> or <code>DateTimeOffset</code>) so that you can retrieve the timestamp later.</p>
<pre><code class="lang-cs">[FirestoreData]
public class HighScore
{
    [FirestoreProperty]
    public int Score { get; set; }

    [FirestoreProperty]
    public string Name { get; set; }

    [FirestoreProperty, ServerTimestamp]
    public Timestamp LastUpdated { get; set; }
}
</code></pre><p>For dictionaries and anonymous types, you can use <code>FieldValue.ServerTimestamp</code> as the value itself. For example,
to update just the <code>Score</code> and <code>Timestamp</code> fields of a <code>HighScore</code> document, you could use an anonymous type instead of
the attributed model</p>
<pre><code class="lang-cs">await document.SetAsync(
    new { Score = 20, LastUpdated = FieldValue.ServerTimestamp },
    SetOptions.MergeAll);
</code></pre><p>Note that each document automatically keeps track of when it was last updated anyway, but you may wish to be more fine-grained;
if a document may change in several ways, you may want a timestamp for when a specific field was last modified.</p>
<h2 id="deleted-fields">Deleted fields</h2>
<p>It can be useful to indicate that a field needs to be deleted from a document, particularly using anonymous types. For example,
to delete a single field in a document, you can use:</p>
<pre><code class="lang-csharp">await doc.Set(new { Score = FieldValue.Delete }, SetOptions.MergeAll);
</code></pre><p>You <em>can</em> specify <code>SentinelValue = SentinelValue.Delete</code> in a property attribute, but this would be highly unusual. It could be useful
as part of a schema migration strategy, for example. It&#39;s mostly supported for the sake of consistency.</p>
<h2 id="array-union-and-removal">Array union and removal</h2>
<p>When updating a document that contains array fields, it can sometimes be inconvenient to update the whole field if you
simply want to either ensure that a specific value is present in the array, or remove it.</p>
<p>The <code>FieldValue.ArrayUnion</code> and <code>FieldValue.ArrayRemove</code> methods allow values to be created (usually as part of anonymous types
for <code>UpdateAsync</code> operations) which express these requirements simply and without a complete &quot;read-modify-write&quot; cycle.</p>
<h2 id="numeric-increment">Numeric increment</h2>
<p>It&#39;s common to need to modify an existing document numeric value by incrementing it by a given amount. While this can be done
with a &quot;read-modify-write&quot; cycle in a transaction, the <code>FieldValue.Increment</code> methods allow values to be created which
perform this increment operation server-side, removing the need for a transaction.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
             
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
